## Notification: 
![#f03c15](https://placehold.it/15/f03c15/000000?text=+) 
Since the coffee shop world generator is under active development, 
the usage might change every once in awhile... I will try my best to keep the documentation up to date! 

![#f03c15](https://placehold.it/15/f03c15/000000?text=+) 
Note that 
[projectSEM/narrative](https://github.com/ProjectSEM/narrative) 
is a forked repo. I work with the original repo at 
[PrincetonCompMemLab/narrative](https://github.com/PrincetonCompMemLab/narrative) 
directly, and I will update push to 
[projectSEM/narrative](https://github.com/ProjectSEM/narrative) 
whenever I made major update. 

## Resources 

Some related papers and data sets can be found 
<a href = "https://github.com/PrincetonCompMemLab/narrative/wiki">here</a>
<br><br>


## Slides from Sep 2017 Princeton meeting:  

History, current status, and future of coffee shop world (7:30-8:15pm)
- Alex - The coffee shop story generator - 
[slides](https://github.com/ProjectSEM/Organization/blob/master/slides/sep_2017/storygeneration_MURI.pdf) 
- Andre - Behavioral experiments - 
[slides](https://github.com/ProjectSEM/Organization/blob/master/slides/sep_2017/andre_MURI_d1.pdf) 
- Qihong - Neural networks for schema learning - 
[slides](https://github.com/ProjectSEM/Organization/blob/master/slides/sep_2017/0917-MURI_Lu.pdf) 
<br><br>

## The coffee shop world "engine" 

The "engine" takes a schema and generates a bunch of stories! Concretely, a schema is a graph {V,E} representing some states and transitions. Each state is a sentence that can be binded with some role fillers. For example, 
<br>

**1. Generate stories** `run_engine.py`

Currently, we have two schema: "poetry reading" and "fight". Here's an exmaple of poetry reading: 

*Mariko walked into the coffee shop on poetry night. She found an empty chair next to Sarah. "Oh hi there Mariko!" said Sarah. "I am glad you could make it Sarah!" Mariko replied. Olivia, who was the emcee for tonight, walked to the front of the room and introduced the first poet, Julian. Julian stepped up to the microphone and read the poem that he had written: "I wandered lonely as a cloud that floats on high over vales and hills, when all at once I saw a crowd, A host, of golden daffodils." The crowd snapped their fingers politely. Mariko had also written a poem, but decided that she was not in the mood to share it today. After all the poets had performed, Mariko and Sarah said their goodbyes and walked toward the door. Mariko made a mental note to come back again next week.*

**how to use**

In the terminal, cd to `\src`, and run the cmd with the following format 
```
python run_engine.py [schema_file_1] [schema_file_2] ... [schema_file_k] [niter] [nrepeats]"
```
where, `schema_file_i` is a txt schema file, `n_iter` is the number of stories and `alternating` is a boolean value that indicates if the generated stories will alternate across the k schemas. For example, the following command generate 8 stories (alternating between 2 poetry stories and 2 fight stories for 2 iterations).
```
python run_engine.py poetry fight 2 2
```
After running the cmd, you will see a file called `schemaFiles_niter_nrepeats.txt` under the `story/schemaFiles_niter_nrepeats/` directory and another "question file" that can be used for 2AFC next state prediction task. 

For example: 
```
Nick was not having it that day, and he promptly stepped back in front of Ben.
Subject.Violent == "Yes"
0.6, Shove, Ben proceeded to give a slight shove to Nick.
0.2, Subject_stares, Ben turned to Nick and gave him a very mean look.
```
The 1st line shows the current state. The 2nd line shows the "probability dependency". If the dependency is "default", it means that the distribution over next states does not depend on the properties of the fillers. In other words, the distribution over next states is determined by the raw markov model. In the example shown above, the raw probability distribution is altered because our subject is "Violent". The 4th line shows the actual next state. The 3rd line shows an alternative next state. Of course, this kind of 2AFC is only possible if the current state has at least two successor nodes. Finally, notice that the probabilities do not necessarily sum to 1, because there are more than 2 possible next states for this particular current state. 

Here's an example of "filler-inconsistent" state, where the alternative state is generated by altering the role-filler binding: 
```
Nick was not having it that day, and he promptly stepped back in front of Ben.
Permute_fillers
0, Shove, Nick proceeded to give a slight shove to Ben.
0.6, Shove, Ben proceeded to give a slight shove to Nick.
```
The 2nd line shows that the alternative state is generated by permuting the fillers. Again, the 4th line shows the actual next state. And the 3rd line shows the permuted state. 

Here's another example, where the alternative next state is generated by replacing the "actual filler" (Silvia) by another already-introduced filler (Ben): 
```
Silvia saw a muffin sitting like ammo next to the cash register, snatched it, and crumbled it above Ben’s head. Everyone in line gasped. Ben, in shock, didn’t move as crumbs tumbled down his ears and shoulders.
Alternative_fillers
0, Barista_orders, The barista ran out from behind the counter and ordered Ben to leave.
0.7, Barista_orders, The barista ran out from behind the counter and ordered Silvia to leave.
```


**Functionalties**: 
- [x] generate stories according to some input schema
- [x] alternate between k schema
- [x] insert state/story boundaries
- [x] generate 2 alternative force choice questions for the next state 
- [ ] plot the graph of the schema (markov model)
- [ ] add "higher order schema"
- [ ] generate sentences, interleaved across k stories? 
<br><br><br>

**2. post-processing** `proc_txt.py`

**how to use**

Having generated a text file contains a bunch of stories (from step 1) under the `story/schemaFiles_niter_nrepeats/` directory, in the terminal, cd to `\src`, and run the cmd with the following format 
```
python proc_txt.py schemaFiles_niter_nrepeats
```
where `schemaFiles_niter_nrepeats` is the name of the directory you just generated from step 1. For example, the following cmd is valid:
```
python proc_txt.py poetry_fight_2_2
```
This procedure generates 3 directories `shuffle_none/`, `shuffle_words/`, `shuffle_states/`, for training data without no shuffling, shuffled words and shuffled states, respectively. Inside each directory, you will see a bunch of files: 
- chars_we.txt - story with end markers 
- chars_woe.txt - story without end markers 
- words_*.npz - python friendly data file, has subfields `train` and `valid` for training and validation 
- word_dict.pickle - the dictionary of the token words 
- metadata.txt - text file version of word_dict.pickle (might add more things in the future)




**Functionalities**: 
- [x] separate training vs. test set and save to .npz file 
- [x] remove punctuation marks
- [x] transform characters to lower case
- [x] insert state/story boundaries
- [x] convert character representations to word representations
- [x] shuffle/reverse the order of words within each state 
- [x] shuffle/reverse the order of sentences within each story
    - [ ] shuffle/reverse every k-words segment (Amy)
- [ ] convert to a cleaner key-value binding test 
    - [ ] replace non-filler words by "blah"
    - [ ] replace the k-th non-filler consecutive-words by "blah_k"

Let me know if you have more suggestions - qlu@princeton.edu
